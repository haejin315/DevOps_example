name: CI
#    Actions 탭에 보이는 워크플로우 이름.

on:
  push:
    branches: [ main, develop, feature/** ]
  pull_request:
    branches: [ main, develop ]
#    언제 실행할지 트리거 정의.
#    - push: main/develop/feature/** 브랜치에 푸시될 때 실행.
#             feature/** 는 feature/login, feature/foo/bar 같은 모든 하위 브랜치 포함.
#    - pull_request: main/develop 대상으로 오는 PR에서 실행.

jobs:
  # 1) 기능 테스트: go test (race 포함, 커버리지 파일 생성 → 다음 job에서 사용)
  go-functional-tests:
    name: 1) Functional tests (go test)
    #    이 job의 화면용 이름. 실행 목록에서 읽히는 이름.

    runs-on: ubuntu-latest
    #    GitHub 호스티드 러너 중 Ubuntu 최신 이미지에서 실행.

    defaults: { run: { working-directory: app } }
    #    이 job 안의 `run:` 스텝들 기본 작업 폴더를 app/ 로 고정.
    #    매번 `cd app` 하지 않아도 됨.

    steps:
      - uses: actions/checkout@v4
        #    현재 커밋의 코드를 러너에 체크아웃(복제).
        #    이게 있어야 실제 소스에 접근 가능.

      - uses: actions/setup-go@v5
        with:
          go-version: '1.24.5'
          cache: true
        #    러너에 Go 도구체인 설치.
        #    go-version: 사용할 Go 버전.
        #    cache: true 면 setup-go가 go.sum 기반으로 모듈 캐시를 복원/저장.
        #    (기본 검색 경로는 **/go.sum, app/go.sum 이 있어야 캐시가 살아요)

      - run: go mod download
        #    go.mod/go.sum 기준으로 모듈 의존성 사전 다운로드.
        #    캐시가 복원돼도 최초 워크스페이스에 모듈 폴더가 없을 수 있어 미리 내려받아 속도/안정성 ↑

      - name: Run unit/integration tests
        run: go test -v -race -covermode=atomic -coverprofile=coverage.out ./...
        #    테스트 실행.
        #    -v                 : 상세 로그 출력(테스트 이름 등)
        #    -race              : 데이터 레이스 탐지기 활성화(병행 코드 안전성 체크)
        #    -covermode=atomic  : 커버리지 카운터를 원자적으로 기록(레이스 옵션과 궁합)
        #    -coverprofile=...  : 커버리지 결과를 coverage.out 파일로 저장
        #    ./...              : app/ 하위 모든 패키지 재귀적으로 테스트
        #    이 스텝은 현재 작업 디렉터리(app/)에서 실행되므로 coverage.out 은 app/에 생성됨.

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: go-coverage
          path: app/coverage.out
        #    다음 job/워크플로우에서 활용할 수 있게 커버리지 파일을 아티팩트로 업로드.
        #    name: 업로드된 묶음의 이름(다운로드 시 보이는 이름)
        #    path: 업로드할 파일 경로. 작업 디렉터리가 app/ 이지만,
        #          upload-artifact는 리포지토리 루트를 기준으로 경로를 해석해도 OK라서 app/coverage.out 로 지정.

  # 2) 빌드 테스트 (Go)
  # - 목적: 소스가 깨지지 않고 정상적으로 빌드되는지 검증
  # - 선행조건: 1) 기능 테스트가 성공해야 실행(빌드 낭비 방지)
  go-build-test:

    # Actions UI에 표시될 사람 읽는 이름
    name: 2) Build test (Go)

    # 이 Job을 실행할 VM 이미지(운영체제)
    runs-on: ubuntu-latest

    # 선행 Job 의존성: go-functional-tests 가 성공해야 이 Job 실행
    needs: go-functional-tests

    # 모든 run 스텝의 기본 작업 디렉토리를 app/ 로 지정
    defaults:
      run:
        working-directory: app

    # 이 아래부터 실제로 실행되는 단계들
    steps:

      # 현재 커밋의 코드를 러너(가상머신)에 체크아웃
      - uses: actions/checkout@v4

      # Go 툴체인을 설치하고(지정 버전), 모듈 캐시 사용
      # go.sum 이 있어야 캐시가 정상 동작함(없으면 경고만 나고 진행은 됨)
      # '1.24.5' 버전이 실제로 존재해야 함. 프로젝트 실제 버전에 맞춰 조정 가능(예: '1.22')
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24.5'
          cache: true

      # go.mod/go.sum 기준으로 의존성 사전 다운로드(빌드 시 네트워크 불확실성/시간 감소)
      - run: go mod download

      # 프로젝트 빌드: 코드가 컴파일 단계부터 깨지지 않는지 확인
      # -v 옵션: 어떤 패키지를 빌드했는지 자세히 로그 출력
      - name: Build Go application
        run: go build -v .